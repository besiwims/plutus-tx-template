//1. function named auctionTypedValidator
//2. has a member function named conditions and  conditions has seven(7) helper functions namely 
//a) sufficientBid
//b) validBidTime
//c) refundsPreviousHighestBid
//d) correctNewDatum
//e) validPayoutTime
//f) sellerGetsHighestBid
//g) highestBidderGetsAsset

//1
{-# INLINEABLE auctionTypedValidator #-}
auctionTypedValidator ::
    AuctionParams ->
    AuctionDatum ->
    AuctionRedeemer ->
    ScriptContext ->
    Bool
auctionTypedValidator params (AuctionDatum highestBid) redeemer ctx@(ScriptContext txInfo _) =
    PlutusTx.and conditions
  where  
    conditions :: [Bool]
    conditions = case redeemer of
        NewBid bid ->
            [ 
              sufficientBid bid //2a) This function sufficientBid is being called and applied on to a value bid(which is data(similar to struct) with 2 fields namely bBidder, bAmount)
            , 
              validBidTime //2b) This function validBidTime is being called has no parameter but returns True/False(Bool)
            , 
              refundsPreviousHighestBid //2c) This function refundsPreviousHighestBid is being called has no parameter but returns True/False(Bool)
            , 
              correctNewDatum bid //2d) This function correctNewDatum is being called has no parameter but returns True/False(Bool)
            ]
        Payout ->
            [ 
              validPayoutTime //2e) This function validPayoutTime is being called has no parameter but returns True/False(Bool)
            , 
              sellerGetsHighestBid //2f) This function sellerGetsHighestBid is being called has no parameter but returns True/False(Bool)
            , 
              highestBidderGetsAsset //2g) This function highestBidderGetsAsset is being called has no parameter but returns True/False(Bool)
            ]

    //2a) This is function definition: i) name of the function - sufficientBid ii) It has 1 parameter of a type Bid and will return a value of a type Bool
	//This is is called function type signature
    sufficientBid :: Bid -> Bool
    sufficientBid (Bid _ amt) = case highestBid of  //Bid is a struct with fields bBidder(here ignored by _) and bAmount (given variable name amt)
        Just (Bid _ amt') -> amt PlutusTx.> amt' //Two amounts are being compared here amt and amt" and this line returns true if amt is > amt' else it returns false
        Nothing -> amt PlutusTx.>= apMinBid params //If amt >= to the computation result of a helper function apMinBid applied on params then it returns true else false
		
    //2b) This is function definition:  name of the function - validBidTime and will return a value of a type Bool
	//This is is called function type signature
    validBidTime :: Bool
    validBidTime = to (apEndTime params) `contains` txInfoValidRange txInfo //This is a helper function checking if the transaction is within the valid range set

    //2c) This is function definition:  name of the function - refundsPreviousHighestBid and will return a value of a type Bool
	//This is is called function type signature
    refundsPreviousHighestBid :: Bool
    refundsPreviousHighestBid = case highestBid of
	    //for now lets leave this, just know this will pay highest bidder or previous highest bidder
        Nothing -> True 
        Just (Bid bidder amt) ->
            case PlutusTx.find
                ( \o ->
                    txOutAddress o
                        PlutusTx.== pubKeyHashAddress bidder
                        PlutusTx.&& txOutValue o
                        PlutusTx.== lovelaceValue amt
                )
                (txInfoOutputs txInfo) of
                Just _ -> True
                Nothing -> PlutusTx.traceError ("Not found: refund output")

    //2d) This is function definition:  i) name of the function - correctNewDatum. ii) It has one parameter of a type Bid and will return a value of a type Bool
	//This is is called function type signature
    correctNewDatum :: Bid -> Bool
    correctNewDatum bid = case getContinuingOutputs ctx of
	//We will come back and explain the logic of case below on transactions list [o] and datum information being checked
        [o] -> case txOutDatum o of
            OutputDatum (Datum newDatum) -> case PlutusTx.fromBuiltinData newDatum of
                Just bid' ->
                    PlutusTx.traceIfFalse
                        ( "Invalid output datum: expected "
                            PlutusTx.<> PlutusTx.show bid
                            PlutusTx.<> ", but got "
                            PlutusTx.<> PlutusTx.show bid'
                        )
                        (bid PlutusTx.== bid')
                Nothing ->
                    PlutusTx.traceError
                        ( "Failed to decode output datum: "
                            PlutusTx.<> PlutusTx.show newDatum
                        )
            OutputDatumHash _ ->
                PlutusTx.traceError "Expected OutputDatum, got OutputDatumHash"
            NoOutputDatum ->
                PlutusTx.traceError "Expected OutputDatum, got NoOutputDatum"
        os ->
            PlutusTx.traceError
                ( "Expected exactly one continuing output, got "
                    PlutusTx.<> PlutusTx.show (PlutusTx.length os)
                )
				
    //2e) This is function definition:  name of the function - validPayoutTime and will return a value of a type Bool
	//This is is called function type signature
    validPayoutTime :: Bool
    validPayoutTime = from (apEndTime params) `contains` txInfoValidRange txInfo //This is similar to the above function `validBidTime`

    //2f) This is function definition:  name of the function - sellerGetsHighestBid and will return a value of a type Bool
	//This is is called function type signature
    sellerGetsHighestBid :: Bool
    sellerGetsHighestBid = case highestBid of
	//This also will be explained on its own lesson. Only thing to know is this gives the highest bid amount to the seller
        Nothing -> True
        Just (Bid _ amt) ->
            case PlutusTx.find
                ( \o ->
                    txOutAddress o
                        PlutusTx.== pubKeyHashAddress (apSeller params)
                        PlutusTx.&& txOutValue o
                        PlutusTx.== lovelaceValue amt
                )
                (txInfoOutputs txInfo) of
                Just _ -> True
                Nothing -> PlutusTx.traceError ("Not found: Output paid to seller")

    //2g) This is function definition:  name of the function - highestBidderGetsAsset and will return a value of a type Bool
	//This is is called function type signature
    highestBidderGetsAsset :: Bool
    highestBidderGetsAsset = case highestBid of
	//This gives the asset to the highest bidder because on above function the the highest bidder amount goes to the seller.
        Nothing -> True
        Just (Bid bidder _) ->
            case PlutusTx.find
                ( \o ->
                    txOutAddress o
                        PlutusTx.== pubKeyHashAddress bidder
                        PlutusTx.&& txOutValue o
                        PlutusTx.== apAsset params
                )
                (txInfoOutputs txInfo) of
                Just _ -> True
                Nothing -> PlutusTx.traceError ("Not found: Output paid to highest bidder")
				
				//The functions 2f) and 2g) are similar in structure in that they are using case ...of to select who gets highest bidder amount and who gets the asset 
				// of the seller
				//Going through the above Plutus code may be intimidating at first but one will realize the pattern as more examples come. There is no need to panic or be afraid.



